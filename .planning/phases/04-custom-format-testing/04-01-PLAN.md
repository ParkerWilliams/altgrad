---
phase: 04-custom-format-testing
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - altgrad/quantization/stability.py
  - altgrad/quantization/__init__.py
  - tests/test_stability.py
autonomous: true

must_haves:
  truths:
    - "Partition-relative clipper scales clip threshold by format dynamic range ratio"
    - "Clipping only activates when overflow rate exceeds 1% threshold"
    - "Emergency mantissa shift triggers on 3+ consecutive NaN batches"
    - "Emergency mantissa shift triggers on >50% bit-stall rate"
    - "Format fallback chain: E7M0->E5M2, E1M6->E3M4, E0M7->E3M4"
  artifacts:
    - path: "altgrad/quantization/stability.py"
      provides: "PartitionRelativeClipper, EmergencyMantissaShift classes"
      exports: ["PartitionRelativeClipper", "EmergencyMantissaShift"]
    - path: "tests/test_stability.py"
      provides: "TDD tests for stability interventions"
      min_lines: 100
  key_links:
    - from: "altgrad/quantization/stability.py"
      to: "altgrad/quantization/formats.py"
      via: "FP8Format.max_representable_value"
      pattern: "format\\.max_representable_value"
    - from: "altgrad/quantization/stability.py"
      to: "torch.nn.utils"
      via: "clip_grad_norm_"
      pattern: "clip_grad_norm_"
---

<objective>
Implement stability interventions (STAB-05, STAB-06) for exotic format experiments.

Purpose: Enable graceful handling of overflow and training collapse when testing E7M0, E1M6, and other formats with limited dynamic range or precision.

Output:
- PartitionRelativeClipper: Format-aware gradient clipping that scales threshold by dynamic range
- EmergencyMantissaShift: Runtime format fallback on persistent NaN or high bit-stall
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-custom-format-testing/04-RESEARCH.md

# Existing code patterns
@altgrad/quantization/formats.py
@altgrad/quantization/diagnostics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1 (RED): Write failing tests for stability interventions</name>
  <files>tests/test_stability.py</files>
  <action>
Create comprehensive tests for STAB-05 and STAB-06:

**PartitionRelativeClipper tests:**
- `test_clip_threshold_scales_by_format_range`: E3M4 (max ~124) should have ~0.2% of E5M2 (max 57344) threshold
- `test_clipper_no_clip_below_overflow_threshold`: Should not clip when overflow_rate < 0.01
- `test_clipper_clips_above_overflow_threshold`: Should clip when overflow_rate >= 0.01
- `test_clipper_returns_clipped_flag`: Returns True when clipping applied, False otherwise
- `test_clipper_with_e7m0_extreme_range`: E7M0 has huge max (~2^64), verify threshold scaling

**EmergencyMantissaShift tests:**
- `test_shift_triggers_on_nan_patience`: Should recommend shift after 3 consecutive NaN batches
- `test_shift_triggers_on_high_stall_rate`: Should recommend shift when stall_rate > 0.5
- `test_shift_resets_nan_counter_on_valid_batch`: Non-NaN batch resets consecutive counter
- `test_shift_returns_none_when_no_shift_needed`: Returns None if neither trigger met
- `test_fallback_chain_e7m0_to_e5m2`: E7M0 -> E5M2
- `test_fallback_chain_e1m6_to_e3m4`: E1M6 -> E3M4
- `test_fallback_chain_e0m7_to_e3m4`: E0M7 -> E3M4
- `test_fallback_chain_e5m2_none`: E5M2 has no fallback (returns None even if triggered)
- `test_shift_both_triggers_nan_and_stall`: Either trigger should cause shift

Run: `pytest tests/test_stability.py -v` - all tests MUST FAIL (classes don't exist yet)

Commit: `test(04-01): add failing tests for stability interventions`
  </action>
  <verify>pytest tests/test_stability.py -v shows all tests fail with ImportError or AttributeError</verify>
  <done>14+ tests written, all failing because PartitionRelativeClipper and EmergencyMantissaShift don't exist</done>
</task>

<task type="auto">
  <name>Task 2 (GREEN): Implement PartitionRelativeClipper</name>
  <files>altgrad/quantization/stability.py, altgrad/quantization/__init__.py</files>
  <action>
Create stability.py with PartitionRelativeClipper:

```python
"""Stability interventions for exotic FP8 format training.

STAB-05: Partition-relative gradient clipping - scale clip threshold by format's
dynamic range relative to E5M2 baseline.

STAB-06: Emergency mantissa shift - fallback to higher-mantissa format when
training shows persistent NaN or high bit-stall rate.
"""

from typing import Optional
import torch
import torch.nn as nn

from altgrad.quantization.formats import FP8Format, FORMAT_REGISTRY

E5M2_MAX = 57344.0  # E5M2 max representable value (baseline)


class PartitionRelativeClipper:
    """Format-aware gradient clipping (STAB-05).

    Scales gradient clip threshold proportionally to format's dynamic range.
    Formats with smaller range (E3M4, E1M6) get proportionally smaller thresholds.

    Only clips when overflow rate exceeds threshold (not always-on).

    Example:
        >>> clipper = PartitionRelativeClipper(E3M4, base_clip=1.0)
        >>> clipped = clipper.clip_if_needed(model, overflow_rate=0.02)
    """

    def __init__(
        self,
        format: FP8Format,
        base_clip: float = 1.0,
        overflow_threshold: float = 0.01  # 1% from CONTEXT.md
    ):
        self.format = format
        self.base_clip = base_clip
        self.overflow_threshold = overflow_threshold

        # Scale threshold by format's range ratio vs E5M2
        format_max = format.max_representable_value
        self.clip_threshold = base_clip * (format_max / E5M2_MAX)

    def clip_if_needed(self, model: nn.Module, overflow_rate: float) -> bool:
        """Apply clipping only when overflow detected.

        Args:
            model: Model to clip gradients on
            overflow_rate: Fraction of values that overflowed [0, 1]

        Returns:
            True if clipping was applied, False otherwise
        """
        if overflow_rate >= self.overflow_threshold:
            torch.nn.utils.clip_grad_norm_(
                model.parameters(),
                self.clip_threshold
            )
            return True
        return False
```

Update altgrad/quantization/__init__.py to export PartitionRelativeClipper.

Run: `pytest tests/test_stability.py -k "clipper" -v`

Commit: `feat(04-01): implement PartitionRelativeClipper for format-aware clipping`
  </action>
  <verify>pytest tests/test_stability.py -k "clipper" -v shows all clipper tests pass</verify>
  <done>PartitionRelativeClipper passes all 5 tests, exported from package</done>
</task>

<task type="auto">
  <name>Task 3 (GREEN): Implement EmergencyMantissaShift</name>
  <files>altgrad/quantization/stability.py, altgrad/quantization/__init__.py</files>
  <action>
Add EmergencyMantissaShift to stability.py:

```python
class EmergencyMantissaShift:
    """Emergency fallback to higher-mantissa format (STAB-06).

    Monitors for:
    - Persistent NaN (3+ consecutive batches with NaN loss)
    - High bit-stall rate (>50% of updates stalled)

    When triggered, recommends fallback to format with more mantissa bits:
    - E7M0 -> E5M2 (powers-of-2 -> standard FP8)
    - E1M6 -> E3M4 (narrow range -> moderate)
    - E0M7 -> E3M4 (fixed-point -> floating)
    - E3M4 -> E5M2 (fallback for E3M4 if needed)
    - E5M2 -> None (no fallback, already widest range)

    Example:
        >>> shifter = EmergencyMantissaShift()
        >>> new_format = shifter.check_and_shift("E7M0", has_nan=True, stall_rate=0.3)
        >>> # Returns "E5M2" after 3 consecutive NaN batches
    """

    # Fallback chain: format -> fallback format with more mantissa
    FORMAT_FALLBACK = {
        "E7M0": "E5M2",   # 0 mantissa -> 2 mantissa
        "E1M6": "E3M4",   # 6 mantissa but tiny range -> 4 mantissa moderate range
        "E0M7": "E3M4",   # Fixed-point -> floating
        "E3M4": "E5M2",   # Moderate -> standard
        "E5M2": None,     # No fallback (widest stable format)
    }

    def __init__(
        self,
        nan_patience: int = 3,
        stall_threshold: float = 0.5
    ):
        self.nan_patience = nan_patience
        self.stall_threshold = stall_threshold
        self.consecutive_nans = 0

    def check_and_shift(
        self,
        current_format: str,
        has_nan: bool,
        stall_rate: float
    ) -> Optional[str]:
        """Check if format shift is needed and return new format.

        Args:
            current_format: Current format name (e.g., "E7M0")
            has_nan: Whether current batch had NaN loss
            stall_rate: Fraction of bit-stalled updates [0, 1]

        Returns:
            New format name if shift needed, None otherwise
        """
        # Track consecutive NaNs
        if has_nan:
            self.consecutive_nans += 1
        else:
            self.consecutive_nans = 0

        # Check triggers
        nan_triggered = self.consecutive_nans >= self.nan_patience
        stall_triggered = stall_rate > self.stall_threshold

        should_shift = nan_triggered or stall_triggered

        if should_shift:
            fallback = self.FORMAT_FALLBACK.get(current_format)
            if fallback is not None:
                self.consecutive_nans = 0  # Reset counter after shift
            return fallback

        return None

    def reset(self) -> None:
        """Reset internal state (call after format shift or run start)."""
        self.consecutive_nans = 0
```

Update __init__.py exports.

Run: `pytest tests/test_stability.py -v`

Commit: `feat(04-01): implement EmergencyMantissaShift for format fallback`
  </action>
  <verify>pytest tests/test_stability.py -v shows all 14+ tests pass</verify>
  <done>Both stability classes implemented and passing all tests</done>
</task>

</tasks>

<verification>
```bash
# All stability tests pass
pytest tests/test_stability.py -v

# Imports work from package
python -c "from altgrad.quantization import PartitionRelativeClipper, EmergencyMantissaShift; print('OK')"

# Quick sanity check
python -c "
from altgrad.quantization import PartitionRelativeClipper, EmergencyMantissaShift, E3M4, E5M2

# Clipper threshold scaling
clipper = PartitionRelativeClipper(E3M4)
print(f'E3M4 clip threshold: {clipper.clip_threshold:.4f}')
print(f'Ratio vs base: {clipper.clip_threshold / 1.0:.4f}')

# Shifter fallback
shifter = EmergencyMantissaShift()
print(f'E7M0 fallback: {shifter.FORMAT_FALLBACK[\"E7M0\"]}')
print(f'E5M2 fallback: {shifter.FORMAT_FALLBACK[\"E5M2\"]}')
"
```
</verification>

<success_criteria>
1. PartitionRelativeClipper scales threshold correctly (E3M4 ~0.2% of E5M2)
2. Clipping only activates on overflow_rate >= 0.01
3. EmergencyMantissaShift triggers on 3+ consecutive NaNs
4. EmergencyMantissaShift triggers on stall_rate > 0.5
5. Fallback chain returns correct format or None for E5M2
6. All tests pass, clean imports from altgrad.quantization
</success_criteria>

<output>
After completion, create `.planning/phases/04-custom-format-testing/04-01-SUMMARY.md`
</output>
