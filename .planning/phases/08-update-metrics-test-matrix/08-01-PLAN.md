---
phase: 08-update-metrics-test-matrix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - altgrad/quantization/flip_metrics.py
  - tests/test_flip_metrics.py
autonomous: true

must_haves:
  truths:
    - "Update count tracks non-zero gradients (attempted updates) per layer"
    - "Flip count tracks actual FP8 representation changes per layer"
    - "Stall ratio = 1 - (flips / updates) computable from tracker state"
    - "Zero updates returns 0.0 stall ratio (not NaN or error)"
  artifacts:
    - path: "altgrad/quantization/flip_metrics.py"
      provides: "WeightFlipTracker with update tracking and stall ratio"
      contains: "get_stall_ratios"
    - path: "tests/test_flip_metrics.py"
      provides: "Tests for update tracking and stall ratio"
      contains: "test_stall_ratio"
  key_links:
    - from: "altgrad/quantization/flip_metrics.py"
      to: "training loop"
      via: "snapshot_pre_step with grad tracking"
      pattern: "update_counts"
---

<objective>
Extend WeightFlipTracker to distinguish attempted updates from successful flips

Purpose: Disambiguate discrete optimization metrics - knowing both "how many weights received gradient" and "how many weights changed FP8 value" reveals gradient effectiveness
Output: WeightFlipTracker with update_counts dict and get_stall_ratios() method
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-update-metrics-test-matrix/08-RESEARCH.md

# Existing implementation to extend
@altgrad/quantization/flip_metrics.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add update tracking to WeightFlipTracker</name>
  <files>altgrad/quantization/flip_metrics.py</files>
  <action>
Extend WeightFlipTracker to track update counts alongside flip counts:

1. Add `update_counts: Dict[str, int] = {}` attribute in __init__

2. Modify `snapshot_pre_step()` to optionally accept gradient tensor:
   - New signature: `snapshot_pre_step(self, name: str, weight: Tensor, format: FP8Format, scale: Tensor, grad: Optional[Tensor] = None)`
   - If grad provided, count non-zero gradients: `(grad.abs() > 1e-10).sum().item()`
   - Store in update_counts (cumulative)
   - Initialize update_counts[name] to 0 if first time

3. Add `get_update_counts() -> Dict[str, int]` method returning update_counts dict

4. Add `get_stall_ratios() -> Dict[str, float]` method:
   - For each layer: `stall_ratio = 1.0 - (flip_counts[name] / update_counts[name])`
   - Return 0.0 if update_counts[name] == 0 (no gradient = no stall)
   - Stall ratio 0.0 = all updates cause flips (ideal)
   - Stall ratio 1.0 = no updates cause flips (complete stall)

5. Add `compute_stall_ratio(flips: int, updates: int) -> float` module-level function:
   - Return 0.0 if updates == 0
   - Return 1.0 - (flips / updates) otherwise

6. Update reset() to clear update_counts

7. Update __all__ to export compute_stall_ratio
  </action>
  <verify>
Run: `python -c "from altgrad.quantization.flip_metrics import WeightFlipTracker, compute_stall_ratio; t = WeightFlipTracker(); print('Has update_counts:', hasattr(t, 'update_counts')); print('Has get_stall_ratios:', hasattr(t, 'get_stall_ratios')); print('stall(10, 100):', compute_stall_ratio(10, 100))"`
Expected output shows: Has update_counts: True, Has get_stall_ratios: True, stall(10, 100): 0.9
  </verify>
  <done>
WeightFlipTracker has update_counts dict, get_update_counts(), get_stall_ratios() methods, and module-level compute_stall_ratio() function
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for update tracking and stall ratio</name>
  <files>tests/test_flip_metrics.py</files>
  <action>
Add new test cases to existing test_flip_metrics.py:

1. `test_compute_stall_ratio_basic()`:
   - compute_stall_ratio(10, 100) == 0.9 (90% stall)
   - compute_stall_ratio(100, 100) == 0.0 (0% stall, all flip)
   - compute_stall_ratio(0, 100) == 1.0 (100% stall, no flips)
   - compute_stall_ratio(0, 0) == 0.0 (no gradient = no stall)

2. `test_tracker_update_counts()`:
   - Create tracker
   - Call snapshot_pre_step with grad tensor having 50 non-zero elements
   - Verify get_update_counts() returns {"layer1": 50}

3. `test_tracker_stall_ratios()`:
   - Create tracker, create weights that will cause some flips
   - Call snapshot_pre_step with grad
   - Call compute_flips_post_step after modifying weights
   - Verify get_stall_ratios() returns correct ratio

4. `test_tracker_stall_ratio_no_updates()`:
   - Call snapshot_pre_step with zero grad tensor
   - Verify get_stall_ratios() returns 0.0 (not NaN)

5. `test_tracker_reset_clears_updates()`:
   - Add some update counts
   - Call reset()
   - Verify update_counts is empty
  </action>
  <verify>
Run: `pytest tests/test_flip_metrics.py -v -k "stall or update" --tb=short`
Expected: All new tests pass
  </verify>
  <done>
5 new test cases covering update tracking and stall ratio computation all pass
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/test_flip_metrics.py -v --tb=short` - All tests pass (existing + new)
2. `python -c "from altgrad.quantization import WeightFlipTracker, compute_stall_ratio"` - Imports work
3. `python -c "from altgrad.quantization.flip_metrics import compute_stall_ratio; assert compute_stall_ratio(10, 100) == 0.9"` - Basic stall ratio correct
</verification>

<success_criteria>
- WeightFlipTracker.update_counts tracks non-zero gradient counts per layer
- WeightFlipTracker.get_stall_ratios() returns Dict[str, float] with stall ratios
- compute_stall_ratio(flips, updates) -> float is exported
- Stall ratio = 0.0 when updates = 0 (no gradient = no stall, not error)
- All tests pass including 5 new update/stall tests
</success_criteria>

<output>
After completion, create `.planning/phases/08-update-metrics-test-matrix/08-01-SUMMARY.md`
</output>
